# 数算机考复习

Updated 1844 GMT+8 May 20, 2024

2024 spring, Complied by 尹柚鑫 2100015878 光华管理学院

## 讲义复习

### week1 introduction

### week2 时间复杂度

冒泡排序

```python
def bubblesort(list):
    for i in range(len(list)):
        for j in range(len(list)-i-1):
            if list[j]>list[j+1]:
                list[j],list[j+1]=list[j+1],list[j]
# 这样排是从小到大排，先排出来的是最大的在最右边
                
def bubble(list):
    for i in range(len(list)-1):
        for j in range(i+1,len(list)):
            if list[j]<list[i]:
                list[j],list[i]=list[i],list[j]
# 这样排是从小到大排，先排出来的是最小的在最左边
```



插入排序

```python
def insertion_sort(arr):
    for i in range(1, len(arr)):
        j = i
        while arr[j - 1] > arr[j] and j > 0:
            arr[j - 1], arr[j] = arr[j], arr[j - 1]
            j -= 1
```



选择排序

```python
def selectsort(arr):
    for i in range(len(arr)):
        min_ind=i
        for j in range(i+1,len(arr)):
            if arr[min_ind]>arr[j]:
                min_ind=j
        arr[i],arr[min_ind]=arr[min_ind],arr[i]

```



快速排序

```python
def quicksort(arr):
    if len(arr)<=1:
        return arr

    else:
        pivot=arr[len(arr)//2]
        left=[x for x in arr if x<pivot]
        middle=[x for x in arr if x==pivot]
        right=[x for x in arr if x>pivot]
        return quicksort(left)+middle+quicksort(right)

def Quicksort(arr, left, right):
    if left < right:
        partition_pos = partition(arr, left, right)
        Quicksort(arr, left, partition_pos - 1)
        Quicksort(arr, partition_pos + 1, right)


def partition(arr, left, right):
    i = left
    j = right - 1
    pivot = arr[right]
    while i <= j:
        while i <= right and arr[i] < pivot:
            i += 1
        while j >= left and arr[j] >= pivot:
            j -= 1
        if i < j:
            arr[i], arr[j] = arr[j], arr[i]
    if arr[i] > pivot:
        arr[i], arr[right] = arr[right], arr[i]
    return i

```



归并排序

```python
def mergeSort(arr):
	if len(arr) <= 1:
		return arr
	mid=len(arr)//2
	left = mergeSort(arr[:mid])	# Dividing the array elements
	right =mergeSort(arr[mid:]) # Into 2 halves

	merged=[]
	while left and right:
		if left[0]<=right[0]:
			merged.append(left.pop(0))
		else:
			merged.append(right.pop(0))
	merged.extend(right if right else left)
	return merged
```

```
res=0
def merge_count(lis):
    if len(lis)<=1:
        return lis
    global res

    mid=len(lis)//2

    left = merge_count(lis[:mid])  # Dividing the array elements
    right = merge_count(lis[mid:])  # Into 2 halves

    merged = []
    while left and right:
        if left[0] <= right[0]:
            merged.append(left.pop(0))
        else:
            merged.append(right.pop(0))
            res+=len(left)
    merged.extend(right if right else left)
    return merged
```

希尔排序

```python
def shellSort(alist):
    sublistcount = len(alist) // 2
    while sublistcount > 0:
        for startposition in range(sublistcount):
            gapInsertionSort(alist, startposition, sublistcount)
        #print("After increments of size", sublistcount, "The list is", alist)

        sublistcount = sublistcount // 2

def gapInsertionSort(alist, start, gap):
    for i in range(start + gap, len(alist), gap):

        currentvalue = alist[i]
        position = i
        while position >= gap and alist[position - gap] > currentvalue:
            alist[position] = alist[position - gap]
            position = position - gap

        alist[position] = currentvalue
```



归并排序可以用来计算逆序数对的数量



02810 求解完全平方，算满足a方等于b方+c方+d方的

暴力方法是枚举，改进方法是，先在数据范围内算所有b方+c方+d方的可能，存在字典里，然后看有没有符合条件的a



230B T-primes 本质上是算一个数是不是素数

朴素方法是On方

埃氏筛法：nlogn

```python
def is_prime(n):
    if n<=1:
        return False
    judge=[True]*(n+1)
    judge[0]=False
    judge[1]=False

    p=2
    while p*p<=n:
        if judge[p]:
            for i in range(p*p,n+1,p):
                judge[i]=False
        p+=1
    return judge[n]
```

欧式筛法：n

```python
def euler(r):
    prime = [0 for i in range(r+1)]
    prime[0]=1
    prime[1]=1
    common = []
    for i in range(2, r+1):
        if prime[i] == 0:
            common.append(i)
        for j in common:
            if i*j > r:
                break
            prime[i*j] = 1
            if i % j == 0:
                break
    return prime 
```



12559 最大最小整数： 可以用冒泡排序的想法做，也可以改进

n个正整数能组成的最大的多位整数和最小的多位整数

```
'''
from math import ceil
# 忽略第一行输入（可以是学生和课程数，这里没有用到）
input()
# 读取第二行输入，并按空格分割成一个字符串列表
lt = input().split()
# 找到最长的字符串的长度
max_len = len(max(lt, key = lambda x: len(x)))
# 按照自定义规则排序列表
lt.sort(key = lambda x: x * ceil(2 * max_len / len(x)))
# 反转排序后的列表
lt1 = lt[::-1]
# 将反转后的列表和排序后的列表分别拼接成字符串，并输出
print(''.join(lt1), ''.join(lt))
'''

# O(n^2)
n = int(input())
nums = input().split()
for i in range(n - 1):
    for j in range(i+1, n):
        #print(i,j)
        if nums[i] + nums[j] < nums[j] + nums[i]:
            nums[i], nums[j] = nums[j], nums[i]

ans = "".join(nums)
nums.reverse()
print(ans + " " + "".join(nums))
```

27373:最大整数

```
def f(string):
    if string=='':
        return 0
    else:
        return int(string)

m=int(input())# 最大位数
n=int(input())# 正整数数量
l=input().split()

# 冒泡排序
for i in range(n):
    for j in range(n-1-i):
        if l[j]+l[j+1]>l[j+1]+l[j]:
            l[j],l[j+1]=l[j+1],l[j]
# 从小到大排序
weight=[len(i) for i in l]

dp=[['']*(m+1) for _ in range(n+1)]
#dp[i][j]表示在前i个数中选，不超过j位
for k in range(m+1):
    dp[0][k]=''
for q in range(n+1):
    dp[q][0]=''
for i in range(1,n+1):
    for j in range(1,m+1):
        if weight[i-1]>j:#肯定不能选,防止超出索引
            dp[i][j]=dp[i-1][j]
        else:
            dp[i][j]=str(max(f(dp[i-1][j]),int(l[i-1]+dp[i-1][j-weight[i-1]])))

print(dp[n][m])
```

在上面这个题目基础上，又增加了一个背包问题dp，非常不错

22507:薛定谔的二叉树

知道前序和后序，算树有几种可能，树的不错的题目，这种一般都是考虑递归，思路很经典

```
def count_trees(preorder, postorder):
    if not preorder and not postorder:
        return 0  # 前序后序都没有
    if not preorder or not postorder:
        return 0  # 前序后序只有一个
    if preorder[0] != postorder[-1]:
        return 0  # 不满足
    if len(preorder) == 1:
        return 1  # 前序只有一个

    count = 0
    for i in range(1, len(preorder)):
        if preorder[1] == postorder[i - 1]:
            left_preorder=preorder[1:i+1]
            right_preorder=preorder[i+1:]
            left_postorder=postorder[0:i]
            right_postorder=postorder[i:len(postorder)-1]
            leftcount=count_trees(left_preorder,left_postorder)
            rightcount=count_trees(right_preorder,right_postorder)
            if i!=len(preorder)-1:
                count=leftcount*rightcount
            elif i==len(preorder)-1:
                count=max(leftcount,rightcount)*2

    return count
```

### week3 简单数据结构



22068:合法出栈序列：

```python
def match(origin, seq):
    if len(origin) != len(seq):
        return False
    stack = []
    bank = list(origin)
    for char in seq:
        # 栈不空或者栈的栈顶匹配char，同时bank中还有
        while (not stack or stack[-1] != char) and bank:
            stack.append(bank.pop(0))
        if not stack or stack[-1] != char:
            return False
        stack.pop()
    return True
```



进制转化：stack的应用：

```
def base_converter(dec_num, base):
    digits = "0123456789ABCDEF"
    
    rem_stack = [] # Stack()
    
    while dec_num > 0:
        rem = dec_num % base
        #rem_stack.push(rem)
        rem_stack.append(rem)
        dec_num = dec_num // base
        
    new_string = ""
    #while not rem_stack.is_empty():
    while rem_stack:
        new_string = new_string + digits[rem_stack.pop()]
        
    return new_string

print(base_converter(25, 2))
print(base_converter(2555, 16))
```

中序表达式转后序表达式：（包含如何处理小数）

```python
def infix_to_postfix(expression):
    precedence = {'+':1, '-':1, '*':2, '/':2}
    stack = []
    postfix = []
    number = ''

    for char in expression:
        if char.isnumeric() or char == '.':
            number += char
        else:
            if number:
                num = float(number)
                postfix.append(int(num) if num.is_integer() else num)
                number = ''
            if char in '+-*/':
                while stack and stack[-1] in '+-*/' and precedence[char] <= precedence[stack[-1]]:
                    postfix.append(stack.pop())
                stack.append(char)
            elif char == '(':
                stack.append(char)
            elif char == ')':
                while stack and stack[-1] != '(':
                    postfix.append(stack.pop())
                stack.pop()

    if number:
        num = float(number)
        postfix.append(int(num) if num.is_integer() else num)

    while stack:
        postfix.append(stack.pop())

    return ' '.join(str(x) for x in postfix)

n = int(input())
for _ in range(n):
    expression = input()
    print(infix_to_postfix(expression))
   
# 正则表达式处理小数：
def tokenize(expression):
    # 使用正则表达式匹配数字和运算符
    tokens = re.findall(r'\d+\.\d+|\d+|\D', expression)
    # 去除多余的空格
    tokens = [token.strip() for token in tokens if token.strip()]
    return tokens
```



前置表达式求值：简单，倒着看就行

后置表达式求值：简单，正着看就行

八皇后：

```
#DFS写法
def solve_n_queens(n):
    solutions=[]
    queens=[-1]*n

    def backtrack(row):
        if row==n:
            solutions.append(queens.copy())
        else:
            for col in range(n):
                if is_valid(row,col):
                    queens[row]=col
                    backtrack(row+1)
                    queens[row]=-1
    def is_valid(row,col):
        for r in range(row):
            if queens[r]==col or abs(row - r) == abs(col - queens[r]):
                return False
        return True
    backtrack(0)
    return solutions
#栈写法
def queen_stack(n):
    stack = []  # 用于保存状态的栈
    solutions = [] # 存储所有解决方案的列表

    stack.append((0, []))  # 初始状态为第一行，所有列都未放置皇后,栈中的元素是 (row, queens) 的元组

    while stack:
        row, cols = stack.pop() # 从栈中取出当前处理的行数和已放置的皇后位置
        if row == n:    # 找到一个合法解决方案
            solutions.append(cols)
        else:
            for col in range(n):
                if is_valid(row, col, cols): # 检查当前位置是否合法
                    stack.append((row + 1, cols + [col]))

    return solutions
```

deque解决：约瑟夫问题



单调栈：

给出项数为 n 的整数数列 a1...an。

定义函数 f(i) 代表数列中第 i 个元素之后第一个大于 ai 的元素的**下标**，。若不存在，则 f(i)=0。

试求出 f(1...n)

```
n=int(input())
a=list(map(int,input().split()))
stack=[]

for i in range(n):
    while stack and a[stack[-1]]<a[i]:
        a[stack.pop()]=i+1
    stack.append(i)
    
while stack:
    a[stack[-1]]=0
    stack.pop()
print(*a)
```

奶牛排队：

```
N = int(input())
heights = [int(input()) for _ in range(N)]

left_bound = [-1] * N
right_bound = [N] * N

stack = []  # 单调栈，存储索引

# 求左侧第一个≥h[i]的奶牛位置
for i in range(N):
    while stack and heights[stack[-1]] < heights[i]:
        stack.pop()

    if stack:
        left_bound[i] = stack[-1]

    stack.append(i)

stack = [] 

# 求右侧第一个≤h[i]的奶牛位
for i in range(N-1, -1, -1):
    while stack and heights[stack[-1]] > heights[i]:
        stack.pop()

    if stack:
        right_bound[i] = stack[-1]

    stack.append(i)

ans = 0

for i in range(N):  # 枚举右端点 B寻找 A，更新 ans
    for j in range(left_bound[i] + 1, i):
        if right_bound[j] > i:
            ans = max(ans, i - j + 1)
            break
print(ans)
```

最小新整数：

给定一个十进制正整数n(0 < n < 1000000000)，每个数位上数字均不为0。n的位数为m。 现在从m位中删除k位(0<k < m)，求生成的新整数最小为多少？ 例如: n = 9128456, k = 2, 则生成的新整数最小为12456

```
def removeKDigits(num, k):
    stack = []
    for digit in num:
        while k and stack and stack[-1] > digit:
            stack.pop()
            k -= 1
        stack.append(digit)
    while k:
        stack.pop()
        k -= 1
    return int(''.join(stack))
t = int(input())
results = []
for _ in range(t):
    n, k = input().split()
    results.append(removeKDigits(n, int(k)))
for result in results:
    print(result)
```

护林员盖房子：

在一片保护林中，护林员想要盖一座房子来居住，但他不能砍伐任何树木。 现在请你帮他计算：保护林中所能用来盖房子的矩形空地的最大面积。

子矩阵边长可以为1，也就是说： 0 0 0 0 0 依然是一个可以盖房子的子矩阵。

思路：化成直方图最大矩形问题的解法。

```
def maximalRectangle(matrix) -> int:
    # 求出行数n和列数m
    n = len(matrix)
    if n == 0:
        return 0

    m = len(matrix[0])
    # 存储每一层的高度
    height = [0 for _ in range(m+1)]
    res = 0
    # 遍历以哪一层作为底层
    for i in range(n):
        sk = [-1]
        for j in range(m+1):
            # 计算j位置的高度，如果遇到0则置为0，否则递增
            h = 0 if j == m or matrix[i][j] == '1' else height[j] + 1
            height[j] = h
            # 单调栈维护长度
            while len(sk) > 1 and h < height[sk[-1]]:
                res = max(res, (j-sk[-2]-1) * height[sk[-1]])
                sk.pop()
            sk.append(j)
    return res
    
    
m, n = map(int, input().split())
a = []
for i in range(m):
    a.extend([input().split()])

print(maximalRectangle(a))
```



MD5加密值计算：

![image-20240605091345801](C:\Users\d6ren\AppData\Roaming\Typora\typora-user-images\image-20240605091345801.png)







### week4-6 植树节

求二叉树深度：dp 或者是类的写法

二叉树输入：

```
3
2 3
-1 -1
-1 -1
```

```python
n=int(input())
dp=[1]*(n+1)
for i in range(1,n+1):
    a,b=map(int,input().split())
    if a!=-1:
        dp[a]=dp[i]+1
    if b!=-1:
        dp[b]=dp[i]+1
print(max(dp))

class TreeNode:
    def __init__(self):
        self.left=None
        self.right=None
# 用递归的想法来计算树的深度
def tree_depth(node):
    if node is None:
        return 0
    left_depth=tree_depth(node.left)
    right_depth=tree_depth(node.right)
    return max(left_depth,right_depth)+1
n=int(input())
nodes=[TreeNode() for _ in range(n)]

## 注意这种处理输入建立树的方式，非常方便
for i in range(n):
    left_index,right_index=map(int,input().split())
    if left_index!=-1:
        nodes[i].left=nodes[left_index]
    if right_index!=-1:
        nodes[i].right=nodes[right_index]
        
root=nodes[0]
depth=tree_depth(root)
print(depth)
```



n叉树高度计算：BFS

```python
from collections import deque

MAX=1001
adj=[[] for i in range(MAX)]

def build_tree(arr,n):
    root_index=0
    for i in range(n):
        if arr[i]==-1:
            root_index=i
        else:
            adj[i].append(arr[i])
            adj[arr[i]].append(i)
    return root_index

def BFS(start):
    vis={}
    q=deque()
    max_level_reached=0

    q.append([start,0])  #第二个数表示层级

    while len(q)>0:
        p=q.popleft()
        vis[p[0]]=1
        max_level_reached=max(max_level_reached,p[1])

        for i in range(len(adj[p[0]])):
            if adj[p[0]][i] not in vis:
                q.append([adj[p[0]][i],p[1]+1])
    return max_level_reached

if __name__ == '__main__':
    parent = [-1, 0, 1, 2, 3]  # node 0 to node n-1
    n = len(parent)  # Number of nodes in tree
    root_index = build_tree(parent, n)
    ma = BFS(root_index)
    print("Height of N-ary Tree =", ma)
    
# Recur For Ancestors of node and store height of node at last
def fillHeight(p, node, visited, height):
    if (p[node] == -1): # If root node
        visited[node] = 1 # mark root node as visited
        return 0

    if (visited[node]):
        return height[node]

    visited[node] = 1

    # recur for the parent node
    height[node] = 1 + fillHeight(p, p[node], visited, height)

    # return calculated height for node
    return height[node]


def findHeight(parent, n):
    ma = 0
    visited = [0] * n
    height = [0] * n

    for i in range(n):
        if (not visited[i]):
            height[i] = fillHeight(parent, i, visited, height)

        ma = max(ma, height[i])

    return ma


# Driver Code
if __name__ == '__main__':
    parent = [-1, 0, 0, 0, 3, 1, 1, 2]
    n = len(parent)

    print("Height of N-ary Tree =", findHeight(parent, n))

# Output: Height of N-ary Tree = 2
```



树的表示：

括号嵌套

邻接表

括号嵌套树：

括号嵌套表达式生成树

```
# A(B(E),C(F,G),D(H(I)))
def parse_tree(s):
    stack=[]
    node=None
    for char in s:
        if char.isalpha():# 如果是字母，创建新节点
            node=TreeNode(char)
            if stack:
                stack[-1].children.append(node)# 如果栈不为空，把节点作为子节点加入到栈顶节点的子节点列表中
        '''
        这个操作如果是left，right定义：
				if stack[-1].left==None:
                    stack[-1].left=node
                else:
                    stack[-1].right=node
        '''
        elif char =='(':# 遇到左括号，当前节点可能会有子节点
            if node:
                stack.append(node)# 把当前节点推入栈中
                node=None
        elif char ==')':# 遇到右括号，子节点列表结束
            if stack:
                node=stack.pop()# 弹出当前节点
    return node# 根节点
```

扩展二叉树的前序，生成树：

```
class TreeNode():
    def __init__(self,value):
        self.value=value
        self.left=None
        self.right=None

def build_tree(lst):
    if not lst:
        return None
    value=lst.pop()
    if value=='.':
        return None

    root=TreeNode(value)
    root.left=build_tree(lst)
    root.right=build_tree(lst)

    return root
lst=lst[::-1]
```

嵌套括号表示法Nested parentheses representation。直接用元组（root, left, right）来代表一棵树。

ABD..EF..G..C.. ('A', ('B', ('D', None, None), ('E', ('F', None, None), ('G', None, None))), ('C', None, None))

```
def build_tree(preorder):
    if not preorder or preorder[0] == '.':
        return None, preorder[1:]
    root = preorder[0]
    left, preorder = build_tree(preorder[1:])
    right, preorder = build_tree(preorder)
    return (root, left, right), preorder
```

n叉树的前序后序遍历：

```
def preorder(node):
    output=[node.value]
    for child in node.children:
        output.extend(preorder(child))
    return ''.join(output)

def postorder(node):
    output=[]
    for child in node.children:
        output.extend(postorder(child))
    output.append(node.value)
    return ''.join(output)
```

二叉树的遍历：

```
def inorder(root):
    if not root:
        return []

    left = inorder(root.left)
    right = inorder(root.right)
    return left + [root.value] + right


def postorder(root):
    if not root:
        return []

    left = postorder(root.left)
    right = postorder(root.right)
    return left + right + [root.value]
```

二叉树层级输出：

```
def level_out(root):
    queue=[root]
    tra=[]
    while queue:
        node=queue.pop(0)
        tra.append(node.value)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    return tra
```

后序表达式转队列表达式：例如，"3 4 + 6 5 * -"的等价队列表达式就是"5 6 4 3 * + -" 。

```
def parse_tree(s):
    stack=[]
    for char in stack:
        node=TreeNode(char)
        if char.isupper():
            node.right=stack.pop(0)
            node.left=stack.pop(0)
        stack.append(node)
    return stack[0]
```

二叉树中序，后序，建树

```
def topreorder(inorder,postorder):
    if not inorder or not postorder:
        return ''
    root_val=postorder[-1]
    root_index=inorder.index(root_val)

    left_inorder=inorder[:root_index]
    right_inorder=inorder[root_index+1:]

    left_postorder=postorder[:len(left_inorder)]
    right_postorder=postorder[len(left_inorder):-1]

    preorder=root_val+topreorder(left_inorder,left_postorder)+topreorder(right_inorder,right_postorder)

    return preorder
    
类的写法：和扩展二叉树建树有一点像
def buildTree(inorder, postorder):
    if not inorder or not postorder:
        return None

    # 后序遍历的最后一个元素是当前的根节点
    root_val = postorder.pop()
    root = TreeNode(root_val)

    # 在中序遍历中找到根节点的位置
    root_index = inorder.index(root_val)

    # 构建右子树和左子树
    root.right = buildTree(inorder[root_index + 1:], postorder)
    root.left = buildTree(inorder[:root_index], postorder)

    return root
```



前中序建树：

```
class TreeNode():
    def __init__(self,value):
        self.value=value
        self.left=None
        self.right=None

def build_tree(preorder,inorder):
    if not preorder or not inorder:
        return None

    root_val=preorder[0]
    root=TreeNode(root_val)
    root_index=inorder.index(root_val)

    root.left=build_tree(preorder[1:1+root_index],inorder[:root_index])
    root.right=build_tree(preorder[1+root_index:],inorder[root_index+1:])

    return root

def postorder_traversal(root):
    if root == None:
        return ''
    return postorder_traversal(root.left)+postorder_traversal(root.right)+root.value

while True:
    try:
        preorder = input().strip()
        inorder = input().strip()
        root = build_tree(preorder, inorder)
        print(postorder_traversal(root))
    except EOFError:
        break
```

哈夫曼编码树：

```
import heapq

class Node:
    def __init__(self, weight, char=None):
        self.weight = weight
        self.char = char
        self.left = None
        self.right = None

    def __lt__(self, other):
        if self.weight == other.weight:
            return self.char < other.char
        return self.weight < other.weight

def build_huffman_tree(characters):
    heap = []
    for char, weight in characters.items():
        heapq.heappush(heap, Node(weight, char))

    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)
        #merged = Node(left.weight + right.weight) #note: 合并后，char 字段默认值是空
        merged = Node(left.weight + right.weight, min(left.char, right.char))
        merged.left = left
        merged.right = right
        heapq.heappush(heap, merged)

    return heap[0]

def encode_huffman_tree(root):
    codes = {}

    def traverse(node, code):
        #if node.char:
        if node.left is None and node.right is None:
            codes[node.char] = code
        else:
            traverse(node.left, code + '0')
            traverse(node.right, code + '1')

    traverse(root, '')
    return codes

def huffman_encoding(codes, string):
    encoded = ''
    for char in string:
        encoded += codes[char]
    return encoded

def huffman_decoding(root, encoded_string):
    decoded = ''
    node = root
    for bit in encoded_string:
        if bit == '0':
            node = node.left
        else:
            node = node.right

        #if node.char:
        if node.left is None and node.right is None:
            decoded += node.char
            node = root
    return decoded

# 读取输入
n = int(input())
characters = {}
for _ in range(n):
    char, weight = input().split()
    characters[char] = int(weight)

#string = input().strip()
#encoded_string = input().strip()

# 构建哈夫曼编码树
huffman_tree = build_huffman_tree(characters)

# 编码和解码
codes = encode_huffman_tree(huffman_tree)

strings = []
while True:
    try:
        line = input()
        strings.append(line)

    except EOFError:
        break

results = []
#print(strings)
for string in strings:
    if string[0] in ('0','1'):
        results.append(huffman_decoding(huffman_tree, string))
    else:
        results.append(huffman_encoding(codes, string))

for result in results:
    print(result)
```

哈夫曼编码：剪绳子

二叉搜索树 BST：小于父节点的键都在左子树中，大于父节点的键则都在右子树中。我们称这个性质为二叉搜索性，特点：中序遍历就是sort。二叉搜索树可以实现快速排序

二叉搜索树的前序遍历，求它的后序遍历：递归

```
def build_tree(lis):
    if len(lis)==0:
        return None
    root=TreeNode(lis[0])
    ind=len(lis)
    for i in range(len(lis)):
        if lis[i]>lis[0]:
            ind=i
            break
    root.left=build_tree(lis[1:ind])
    root.right=build_tree(lis[ind:])

    return root
```

另一种方法：二叉搜索树的中序遍历就是sort排序之后的结果，相当于前序和中序建树

```
def build(preorder, inorder):
    if not preorder or not inorder:
        return None
    root_val = preorder[0]
    root = Node(root_val)
    root_index = inorder.index(root_val)
    root.left = build(preorder[1:root_index + 1], inorder[:root_index])
    root.right = build(preorder[root_index + 1:], inorder[root_index + 1:])
    return root


def postorder(root):
    if not root:
        return []
    if root.left is None and root.right is None:
        return [root.val]
    result = []
    result += postorder(root.left)
    result += postorder(root.right)
    result += [root.val]
    return result


input()
preorder = list(map(int, input().split()))
inorder = sorted(preorder)
root = build(preorder, inorder)
result = postorder(root)
print(' '.join(map(str, result)))
```

给一行数，建立二叉搜索树：

```
def insert(node, value):
    if node is None:
        return TreeNode(value)
    if value < node.value:
        node.left = insert(node.left, value)
    elif value > node.value:
        node.right = insert(node.right, value)
    return node
```

并查集 Disjoint Set

```python
def find(i):
    # 如果 i 是它自己的父节点
    if Parent[i] == i:
        # 那么 i 是代表
        return i
    else:
        # 递归查找代表
        result = find(Parent[i])
        # 缓存结果，将 i 的节点直接移动到该集合的代表节点下
        Parent[i] = result
        # 返回结果
        return result
```



班级最高分：

```python
def find(x):
    if parent[x]!=x:
        parent[x]=find(parent[x])
    return parent[x]

def union(x,y):
    root_x=find(x)
    root_y=find(y)
    if root_y!=root_x:
        parent[root_x]=root_y
        scores[root_y]=max(scores[root_y],scores[root_x])

n,m=map(int,input().split())
parent=list(range(n+1))
scores=[*map(int,input().split())]
scores.insert(0,0)


for _ in range(m):
    a,b=map(int,input().split())
    union(a,b)

class_scores=[scores[find(x)] for x in range(1,n+1) if parent[x]==x]
print(len(class_scores))
print(' '.join(map(str,sorted(class_scores,reverse=True))))
```



按照rank合并：

```
class DisjSet:
	def __init__(self, n):
		# Constructor to create and initialize sets of n items
		self.rank = [1] * n
		self.parent = [i for i in range(n)]


	# Finds set of given item x
	def find(self, x):
		
		# Finds the representative of the set that x is an element of
		if (self.parent[x] != x):
			
			# if x is not the parent of itself
			# Then x is not the representative of its set
			self.parent[x] = self.find(self.parent[x])
			
			# so we recursively call Find on its parent
			# and move i's node directly under the
			# representative of this set

		return self.parent[x]


	# Do union of two sets represented by x and y.
	def Union(self, x, y):
		
		# Find current sets of x and y
		xset = self.find(x)
		yset = self.find(y)

		# If they are already in same set
		if xset == yset:
			return

		# Put smaller ranked item under
		# bigger ranked item if ranks are different
		if self.rank[xset] < self.rank[yset]:
			self.parent[xset] = yset

		elif self.rank[xset] > self.rank[yset]:
			self.parent[yset] = xset

		# If ranks are same, then move y under x (doesn't matter
    # which one goes where) and increment rank of x's tree
		else:
			self.parent[yset] = xset
			self.rank[xset] = self.rank[xset] + 1
```



按照长度合并：

```
class UnionFind:
	def __init__(self, n):
		self.Parent = list(range(n))
		self.Size = [1] * n

	# Function to find the representative (or the root node) for the set that includes i
	def find(self, i):
		if self.Parent[i] != i:
			# Path compression: Make the parent of i the root of the set
			self.Parent[i] = self.find(self.Parent[i])
		return self.Parent[i]

	# Unites the set that includes i and the set that includes j by size
	def unionBySize(self, i, j):
		# Find the representatives (or the root nodes) for the set that includes i
		irep = self.find(i)

		# And do the same for the set that includes j
		jrep = self.find(j)

		# Elements are in the same set, no need to unite anything.
		if irep == jrep:
			return

		# Get the size of i’s tree
		isize = self.Size[irep]

		# Get the size of j’s tree
		jsize = self.Size[jrep]

		# If i’s size is less than j’s size
		if isize < jsize:
			# Then move i under j
			self.Parent[irep] = jrep

			# Increment j's size by i's size
			self.Size[jrep] += self.Size[irep]
		# Else if j’s size is less than i’s size
		else:
			# Then move j under i
			self.Parent[jrep] = irep

			# Increment i's size by j's size
			self.Size[irep] += self.Size[jrep]
```

食物链：

```python
class DisjSet:
    def __init__(self, n):
        # 设[1,n] 区间表示同类，[n+1,2*n]表示x吃的动物，[2*n+1,3*n]表示吃x的动物
        self.rank = [0] * (3*n+1)
        self.parent = [i for i in range(3*n+1)]

    def find(self, x):
        if (self.parent[x] != x):
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def Union(self, x, y):
        xset = self.find(x)
        yset = self.find(y)

        if xset == yset:
            return

        if self.rank[xset] < self.rank[yset]:
            self.parent[xset] = yset
        elif self.rank[xset] > self.rank[yset]:
            self.parent[yset] = xset
        else:
            self.parent[yset] = xset
            self.rank[xset] = self.rank[xset] + 1
        return
def is_valid(n,k,statements):
    dsu=DisjSet(n)

    def find_disjset(x):
        if x>n:
            return False
        return True

    false_count=0
    for d,x,y in statements:
        if not find_disjset(x) or not find_disjset(y):
            false_count+=1
            continue
        if d==1:#X与Y是同类
            if dsu.find(x)==dsu.find(y+n) or dsu.find(x) == dsu.find(y + 2 * n):
                false_count+=1
            else:
                dsu.Union(x,y)
                dsu.Union(x+n,y+n)
                dsu.Union(x+2*n,y+2*n)
        else: #X吃Y
            if dsu.find(x)==dsu.find(y) or dsu.find(x + 2*n) == dsu.find(y):
                false_count+=1
            else:
                dsu.Union(x+n,y)
                dsu.Union(x,y+2*n)
                dsu.Union(x+2*n,y+n)
    return false_count

if __name__ == "__main__":
    N, K = map(int, input().split())
    statements = []
    for _ in range(K):
        D, X, Y = map(int, input().split())
        statements.append((D, X, Y))
    result = is_valid(N, K, statements)
    print(result)
```

找suspects：

```
def find_sus(n,groups):
    uf=UnionFind(n)

    for group in groups:
        for stu in group[1:]:
            uf.union(group[0],stu)

    sus_set=set()
    for i in range(n):
        if uf.find(0)==uf.find(i):
            sus_set.add(i)
    return len(sus_set)
```

发现他，抓住他：

```
def solve():
    n,m=map(int,input().split())
    ur=DisjSet(2*n)
    for _ in range(m):
        mode,a,b=input().split()
        a=int(a)-1
        b=int(b)-1

        if mode=='D':
            ur.Union(a,b+n)
            ur.Union(b,a+n)
        else:
            parent_a=ur.find(a)
            parent_b=ur.find(b)

            if parent_a==parent_b or ur.find(a+n)==ur.find(n+b):
                print('In the same gang.')
            elif parent_a==ur.find(n+b) or parent_b==ur.find(a+n):
                print('In different gangs.')
            else:
                print('Not sure yet.')
```

冰可乐：

```
def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]

def union(x, y):
    root_x = find(x)
    root_y = find(y)
    if root_x != root_y:
        parent[root_y] = root_x

while True:
    try:
        n, m = map(int, input().split())
        parent = list(range(n + 1))

        for _ in range(m):
            a, b = map(int, input().split())
            if find(a) == find(b):
                print('Yes')
            else:
                print('No')
                union(a, b)

        unique_parents = set(find(x) for x in range(1, n + 1))  # 获取不同集合的根节点
        ans = sorted(unique_parents)  # 输出有冰阔落的杯子编号
        print(len(ans))
        print(*ans)

    except EOFError:
        break
```

班级最高分：

```
def find(x):
    if parent[x]!=x:
        parent[x]=find(parent[x])
    return parent[x]

def union(x,y):
    root_x=find(x)
    root_y=find(y)
    if root_y!=root_x:
        parent[root_x]=root_y
        scores[root_y]=max(scores[root_y],scores[root_x])

n,m=map(int,input().split())
parent=list(range(n+1))
scores=[*map(int,input().split())]
scores.insert(0,0)


for _ in range(m):
    a,b=map(int,input().split())
    union(a,b)

class_scores=[scores[find(x)] for x in range(1,n+1) if parent[x]==x]
print(len(class_scores))
print(' '.join(map(str,sorted(class_scores,reverse=True))))
```



前缀树（Trie Tree）：最长前缀匹配，自动补全

```
class TrieNode:
	def __init__(self):
		# pointer array for child nodes of each node
		self.childNode = [None] * 26
		self.wordCount = 0
		
def insert_key(root, key):
	# Initialize the currentNode pointer with the root node
	currentNode = root

	# Iterate across the length of the string
	for c in key:
		# Check if the node exist for the current character in the Trie.
		if not currentNode.childNode[ord(c) - ord('a')]:
			# If node for current character does not exist
			# then make a new node
			newNode = TrieNode()
			# Keep the reference for the newly created node.
			currentNode.childNode[ord(c) - ord('a')] = newNode
		# Now, move the current node pointer to the newly created node.
		currentNode = currentNode.childNode[ord(c) - ord('a')]
	# Increment the wordEndCount for the last currentNode
	# pointer this implies that there is a string ending at currentNode.
	currentNode.wordCount += 1
	
def search_key(root, key):
	# Initialize the currentNode pointer with the root node
	currentNode = root

	# Iterate across the length of the string
	for c in key:
		# Check if the node exist for the current character in the Trie.
		if not currentNode.childNode[ord(c) - ord('a')]:
			# Given word does not exist in Trie
			return False
		# Move the currentNode pointer to the already existing node for current character.
		currentNode = currentNode.childNode[ord(c) - ord('a')]

	return currentNode.wordCount > 0

def delete_key(root, word):
	currentNode = root
	lastBranchNode = None
	lastBrachChar = 'a'

	for c in word:
		if not currentNode.childNode[ord(c) - ord('a')]:
			return False
		else:
			count = 0
			for i in range(26):
				if currentNode.childNode[i]:
					count += 1
			if count > 1:
				lastBranchNode = currentNode
				lastBrachChar = c
			currentNode = currentNode.childNode[ord(c) - ord('a')]

	count = 0
	for i in range(26):
		if currentNode.childNode[i]:
			count += 1

	# Case 1: The deleted word is a prefix of other words in Trie.
	if count > 0:
		currentNode.wordCount -= 1
		return True

	# Case 2: The deleted word shares a common prefix with other words in Trie.
	if lastBranchNode:
		lastBranchNode.childNode[ord(lastBrachChar) - ord('a')] = None
		return True
	# Case 3: The deleted word does not share any common prefix with other words in Trie.
	else:
		root.childNode[ord(word[0]) - ord('a')] = None
		return True
```

散列？

遍历树，输出是按照当前节点和子节点从小到大的顺序：

```python
class TreeNode():
    def __init__(self,value):
        self.value=value
        self.children=[]
# 这种字典来处理树的方法非常简便
def traverse_print(root,nodes):
    if root.children==[]:
        print(root.value)
        return
    pac={root.value:root}
    for child in root.children:
        pac[child]=nodes[child]
    for value in sorted(pac.keys()):
        if value in root.children:
            traverse_print(pac[value],nodes)
        else:
            print(root.value)

n=int(input())
nodes={}
children_list=[]
for i in range(n):
    info=list(map(int,input().split()))
    nodes[info[0]]=TreeNode(info[0])
    for child_value in info[1:]:
        nodes[info[0]].children.append(child_value)
        children_list.append(child_value)
root=nodes[[value for value in nodes.keys() if value not in children_list][0]]
traverse_print(root,nodes)
```

字典树：电话号码查找

```python
class TrieNode:
    def __init__(self):
        self.child={}

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, nums):
        curnode = self.root
        for x in nums:
            if x not in curnode.child:
                curnode.child[x] = TrieNode()
            curnode=curnode.child[x]

    def search(self, num):
        curnode = self.root
        for x in num:
            if x not in curnode.child:
                return 0
            curnode = curnode.child[x]
        return 1

t = int(input())
p = []
for _ in range(t):
    n = int(input())
    nums = []
    for _ in range(n):
        nums.append(str(input()))
    nums.sort(reverse=True)
    s = 0
    trie = Trie()
    for num in nums:
        s += trie.search(num)
        trie.insert(num)
    if s > 0:
        print('NO')
    else:
        print('YES')
```









### week7 查漏补缺

### week8-10 图

图的表示：

邻接矩阵、邻接表、类写法

BFS：

```
def bfs(self, startNode):
        # Create a queue for BFS
        queue = deque()
        visited = set()

        # Mark the current node as visited and enqueue it
        visited.add(startNode)
        queue.append(startNode)

        # Iterate over the queue
        while queue:
            # Dequeue a vertex from queue and print it
            currentNode = queue.popleft()
            print(currentNode, end=" ")

            # Get all adjacent vertices of the dequeued vertex currentNode
            # If an adjacent has not been visited, then mark it visited and enqueue it
            for neighbor in self.adjList[currentNode]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
```

```
def find_multiple(n):
    q=deque()
    q.append((1%n,'1'))
    visited=set([1%n])

    while q:
        mod,num=q.popleft()

        if mod==0:
            return num
        for digit in ['0','1']:
            new_num=num+digit
            new_mod=(mod*10+int(digit))%n

            if new_mod not in visited:
                q.append((new_mod,new_num))
                visited.add(new_mod)
```

词梯问题：

```
from collections import deque
from collections import defaultdict

def construct_graph(words):
    graph=defaultdict(list)
    for word in words:
        for i in range(len(word)):
            pattern=word[:i]+'_'+word[i+1:]
            graph[pattern].append(word)
    return graph

def bfs(start,end,graph):
    queue=deque()
    queue.append((start,[start]))
    visited=set()
    visited.add(start)

    while queue:
        word,path=queue.popleft()
        if word==end:
            return path
        for i in range(len(word)):
            pattern=word[:i]+'_'+word[i+1:]
            neighbors=graph[pattern]
            for neighbor in neighbors:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append((neighbor,path+[neighbor]))
    return None

n=int(input())
words=[input() for _ in range(n)]
start,end=input().split()
graph=construct_graph(words)
path=bfs(start,end,graph)
if path:
    print(' '.join(path))
else:
    print('NO')
```

马走日 DFS：

```
sx = [-2,-1,1,2, 2, 1,-1,-2]
sy = [ 1, 2,2,1,-1,-2,-2,-1]

ans=0

def dfs(x,y,depth):
    if depth==n*m:
        global ans
        ans+=1
        return
    for i in range(8):
        s=x+sx[i]
        t=y+sy[i]

        if chess[s][t]==False and 0<=s<n and 0<=t<m:
            chess[s][t]=True
            dfs(s,t,depth+1)
            chess[s][t]=False
for _ in range(int(input())):
    n,m,x,y=map(int,input().split())
    chess=[[False]*10 for _ in range(10)]
    ans=0
    chess[x][y]=True
    dfs(x,y,1)
    print(ans)
```

求无向图联通块：

```python
def dfs(node, visited, adjacency_list):
    visited[node] = True
    for neighbor in adjacency_list[node]:
        if not visited[neighbor]:
            dfs(neighbor, visited, adjacency_list)

n, m = map(int, input().split())
adjacency_list = [[] for _ in range(n)]
for _ in range(m):
    u, v = map(int, input().split())
    adjacency_list[u].append(v)
    adjacency_list[v].append(u)

visited = [False] * n
connected_components = 0
for i in range(n):
    if not visited[i]:
        dfs(i, visited, adjacency_list)
        connected_components += 1

print(connected_components)
```

有向图，判断是否成环：

```
# 接收数据
n, m = map(int, input().split())
edges = []
for _ in range(m):
    u, v = map(int, input().split())
    edges.append((u, v))

def has_cycle(n,edges):
    graph=[[] for _ in range(n)]
    for u,v in edges:
        graph[u].append(v)

    color=[0]*n

    def dfs(node):
        if color[node]==1: #遇到正在访问，表明成环
            return True
        if color[node]==2: #已经访问
            return False

        color[node]=1
        for neighbor in graph[node]:
            if dfs(neighbor):
                return True
        color[node]=2 #表明到尽头了
        return False
    for i in range(n):
        if dfs(i):
            return 'Yes'
    return 'No'
print(has_cycle(n,edges))
```



无向图，最大权值连通块

```
def max_weight(n, m, weights, edges):
    graph = [[] for _ in range(n)]
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    visited = [False] * n
    max_weight = 0

    def dfs(node):
        visited[node] = True
        total_weight = weights[node]
        for neighbor in graph[node]:
            if not visited[neighbor]:
                total_weight += dfs(neighbor)
        return total_weight

    for i in range(n):
        if not visited[i]:
            max_weight = max(max_weight, dfs(i))

    return max_weight

# 接收数据
n, m = map(int, input().split())
weights = list(map(int, input().split()))
edges = []
for _ in range(m):
    u, v = map(int, input().split())
    edges.append((u, v))

# 调用函数
print(max_weight(n, m, weights, edges))
```

拓扑排序：

Kahn算法

from collections import deque, defaultdict

def topological_sort(graph):
    indegree = defaultdict(int)
    result = []
    queue = deque()

    # 计算每个顶点的入度
    for u in graph:
        for v in graph[u]:
            indegree[v] += 1
    
    # 将入度为 0 的顶点加入队列
    for u in graph:
        if indegree[u] == 0:
            queue.append(u)
    
    # 执行拓扑排序
    while queue:
        u = queue.popleft()
        result.append(u)
    
        for v in graph[u]:
            indegree[v] -= 1
            if indegree[v] == 0:
                queue.append(v)
    
    # 检查是否存在环，存在环表明无法进行拓扑排序
    if len(result) == len(graph):
        return result
    else:
        return None

先导课程：

```
# 拓扑排序
# 这里BFS的queue并没有用deque，或许是因为deque不能sort排序
# visited，indegree，queue，result
from collections import defaultdict

def courseSchedule(n,edges):
    graph=defaultdict(list)
    indegree=[0]*n
    for u,v in edges:
        graph[u].append(v)
        indegree[v]+=1

    queue=[i for i in range(n) if indegree[i]==0]
    queue.sort()
    result=[]

    while queue:
        u=queue.pop(0)
        result.append(u)
        for v in graph[u]:
            indegree[v]-=1
            if indegree[v]==0:
                queue.append(v)
        queue.sort()

    if len(result)==n:
        return "Yes",result
    else:
        return "No",n-len(result)

n, m = map(int, input().split())
edges = [list(map(int, input().split())) for _ in range(m)]
res, courses = courseSchedule(n, edges)
print(res)
if res == "Yes":
    print(*courses)
else:
    print(courses)
```

01094:Sorting It All Out   想清楚是中途判断的任务还是结尾判断

```
from collections import defaultdict
from collections import deque

def topo_sort(graph):
    indegree= {u:0 for u in graph}
    for u in graph:
        for v in graph[u]:
            indegree[v]+=1

    q=deque([u for u in indegree if indegree[u]==0])
    topo_result=[]
    flag=True
    while q:
        if len(q)>1:
            flag=False   #拓扑排序不唯一
        u=q.popleft()
        topo_result.append(u)
        for v in graph[u]:
            indegree[v]-=1
            if indegree[v]==0:
                q.append(v)
    if len(topo_result) != len(graph):
        return 0  #表明有环，矛盾
    if flag:
        return topo_result
    else:
        return None

while True:
    n,m=map(int,input().split())
    if n==0:
        break
    else:
        edges=[tuple(input().split('<')) for _ in range(m)]
        graph={chr(x+65):[] for x in range(n)}
        for i in range(m):
            a,b=edges[i]
            graph[a].append(b)
            t=topo_sort(graph)
            if t:
                s=''.join(t)
                print(f'Sorted sequence determined after {i+1} relations: {s}.')
                break
            elif t==0:
                print(f'Inconsistency found after {i+1} relations.')
                break
        else:
            print(f'Sorted sequence cannot be determined.')
```







强连通单元：有向图中，该单元中的任意两个顶点v,w，都存在v到w和w到v的道路

寻找有向图中的强连通单元：

Kosaraju算法的核心思想就是两次深度优先搜索（DFS）

1. **第一次DFS**：在第一次DFS中，我们对图进行标准的深度优先搜索，但是在此过程中，我们记录下顶点完成搜索的顺序。这一步的目的是为了找出每个顶点的完成时间（即结束时间）。
2. **反向图**：接下来，我们对原图取反，即将所有的边方向反转，得到反向图。
3. **第二次DFS**：在第二次DFS中，我们按照第一步中记录的顶点完成时间的逆序，对反向图进行DFS。这样，我们将找出反向图中的强连通分量。

```python
def dfs1(graph, node, visited, stack):
    visited[node] = True
    for neighbor in graph[node]:
        if not visited[neighbor]:
            dfs1(graph, neighbor, visited, stack)
    stack.append(node)


def dfs2(graph, node, visited, component):
    visited[node] = True
    component.append(node)
    for neighbor in graph[node]:
        if not visited[neighbor]:
            dfs2(graph, neighbor, visited, component)


def kosaraju(graph):
    # Step 1: Perform first DFS to get finishing times
    stack = []
    visited = [False] * len(graph)
    for node in range(len(graph)):
        if not visited[node]:
            dfs1(graph, node, visited, stack)

    # Step 2: Transpose the graph
    transposed_graph = [[] for _ in range(len(graph))]
    for node in range(len(graph)):
        for neighbor in graph[node]:
            transposed_graph[neighbor].append(node)

    # Step 3: Perform second DFS on the transposed graph to find SCCs
    visited = [False] * len(graph)
    sccs = []
    while stack:
        node = stack.pop()
        if not visited[node]:
            scc = []
            dfs2(transposed_graph, node, visited, scc)
            sccs.append(scc)
    return sccs


# Example
graph = [[1], [2, 4], [3, 5], [0, 6], [5], [4], [7], [5, 6]]
sccs = kosaraju(graph)
print("Strongly Connected Components:")
for scc in sccs:
    print(scc)

"""
Strongly Connected Components:
[0, 3, 2, 1]
[6, 7]
[5, 4]

"""
```

最短路径：

BFS适用于无权图的最短路径问题，而Dijkstra算法适用于有权图的最短路径问题

- Dijkstra算法是一种有权图的最短路径算法，它通过贪心策略逐步确定从起始顶点到所有其他顶点的最短路径。
- BFS使用队列来保存待访问的顶点，并按照顺序进行遍历。它不考虑权重，只关注路径的长度。
- Dijkstra算法使用优先队列（通常是最小堆）来保存待访问的顶点，并按照顶点到起始顶点的距离进行排序。它根据路径长度来决定下一个要访问的顶点，从而保证每次都是选择最短路径的顶点进行访问。

#### Dijkstra用到了优先队列，注意一定要把weight放在vertex前面

- 邻接表：Dijkstra 算法通常使用邻接表来表示图的结构，这样可以高效地存储图中的节点和边。
- 集合：在算法中需要跟踪已经访问过的节点，以避免重复访问，这一般使用集合（或哈希集合）来实现。
- 优先队列（堆）：Dijkstra 算法中需要选择下一个要探索的节点，通常使用优先队列（堆）来维护当前候选节点的集合，并确保每次都能快速找到距离起点最近的节点。
- 贪心算法：Dijkstra 算法每次选择距离起点最近的节点作为下一个要探索的节点，这是一种贪心策略，即每次做出局部最优的选择，期望最终能达到全局最优。
- 动态规划：Dijkstra 算法通过不断地更新节点的最短距离来逐步得到从起点到各个节点的最短路径，这是一种动态规划的思想，即将原问题拆解成若干子问题，并以最优子结构来解决。

```
import heapq

def dijkstra(n,edges,s,t):
    graph=[[]for _ in range(n)]
    for u,v,w in edges:
        graph[u].append((v,w))
        graph[v].append((u,w))

    pq=[(0,s)]  #距离，位置
    visited=set()
    distances=[float('inf')]*n
    distances[s]=0

    while pq:
        dist,node=heapq.heappop(pq)
        if node ==t:
            return dist
        if node in visited:
            continue
        visited.add(node)
        for neighbor,weight in graph[node]:
            if neighbor not in visited:
                new_dist=dist+weight
                if new_dist<distances[neighbor]:
                    distances[neighbor]=new_dist
                    heapq.heappush(pq,(new_dist,neighbor))
    return -1
n, m, s, t = map(int, input().split())
edges = [list(map(int, input().split())) for _ in range(m)]

# Solve the problem and print the result
result = dijkstra(n, edges, s, t)
print(result)
```

```
def dijkstra(n,edges,start,destination,max_coin):
    graph=[[]for _ in range(n)]
    for s,d,l,t in edges:
        graph[s-1].append((d-1,l,t))

    pq=[(0,0,start)]  #距离，钱，位置
    visited=set()

    while pq:
        dist,coin,node=heapq.heappop(pq)

        if node ==destination:
            return dist

        visited.add((node,coin))

        for neighbor,length,cost in graph[node]:

            if (neighbor,cost+coin) not in visited:
                new_dist=dist+length
                new_cost=coin+cost
                if new_cost<=max_coin:
                    heapq.heappush(pq,(new_dist,new_cost,neighbor))
    return -1
```

变换迷宫：

    import heapq
    def dijkstra(start,mappp):
        visited=set((0,start))
        pq=[(0,start)] #时间，节点
    
        while pq:
            distance, node = heapq.heappop(pq)
            
            for dx, dy in direc:
                newx = node[0] + dx
                newy = node[1] + dy
                dist = (distance + 1) % K
                if 0 <= (newx) < R and 0 <= (newy) < C and (dist, (newx, newy)) not in visited:
                    if mappp[newx][newy] == 'E':
                        return distance + 1
                    elif mappp[newx][newy] != '#' or dist == 0:
                        heapq.heappush(pq, (distance + 1, (newx, newy)))
                        visited.add((dist, (newx, newy)))
        return -1
    direc = [(0,1), (1,0), (-1,0), (0,-1)]
    num=int(input())
    for _ in range(num):
        R,C,K=map(int,input().split())
        mappp=[list(input()) for _ in range(R)]
    
        start=None
        for i in range(R):
            for j in range(C):
                if mappp[i][j]=='S':
                    start=(i,j)
                    break
            if start:
                break
        result = dijkstra(start, mappp)
        if result == -1:
            print('Oop!')
        else:
            print(result)
最小生成树：MSTs **如果是稠密图(边多)，则用 prim 算法;如果是稀疏图(边少)，则用 kruskal 算法**。

#### prim用到了优先队列，注意一定要把weight放在vertex前面

- Prim算法是一种用于解决最小生成树（MST）问题的贪心算法，它会逐步构建一个包含所有顶点的树，并且使得树的边权重之和最小。
- BFS是一种用于无权图的遍历算法，它按照层次遍历的方式访问图的所有节点，并找到从起始顶点到其他所有顶点的最短路径。
- Prim算法通过选择具有最小权重的边来扩展生成树，并且只考虑与当前生成树相邻的顶点。
- BFS通过队列来保存待访问的顶点，并按照顺序进行遍历，不考虑边的权重。

```
import heapq

def prim(graph, n):
    visited = [False] * n
    min_heap = [(0, 0)]  # (weight, vertex)
    min_spanning_tree_cost = 0

    while min_heap:
        weight, vertex = heapq.heappop(min_heap)

        if visited[vertex]:
            continue

        visited[vertex] = True
        min_spanning_tree_cost += weight

        for neighbor, neighbor_weight in graph[vertex]:
            if not visited[neighbor]:
                heapq.heappush(min_heap, (neighbor_weight, neighbor))

    return min_spanning_tree_cost if all(visited) else -1
    # else表明的是图不联通，自然没有最小生成树

def main():
    n, m = map(int, input().split())
    graph = [[] for _ in range(n)]

    for _ in range(m):
        u, v, w = map(int, input().split())
        graph[u].append((v, w))
        graph[v].append((u, w))

    min_spanning_tree_cost = prim(graph, n)
    print(min_spanning_tree_cost)

if __name__ == "__main__":
    main()

```

卡车：

```
def prim():
    visited=[False]*n
    min_heap=[(0,0)]  #weight,vertex
    mst=0
    distances=[float('inf')]*n
    distances[0]=0

    while min_heap:
        weight,vertex=heapq.heappop(min_heap)
        if not visited[vertex]:
            mst+=weight
            visited[vertex]=True

            for i in range(n):
                if not visited[i]:
                    w=cal_weight(s[i],s[vertex])
                    if w<distances[i]:
                        distances[i]=w
                        heapq.heappush(min_heap,(w,i))
    return mst
```

Kruskal算法通常与并查集（Disjoint Set）结构一起使用，但它们并不是同一种算法。

1. **Kruskal算法**：

   - Kruskal算法是一种用于解决最小生成树（MST）问题的贪心算法。它通过不断选择具有最小权重的边，并确保选择的边不形成环，最终构建出一个包含所有顶点的最小生成树。
   - 在Kruskal算法中，通常会使用并查集来维护图中顶点的连通性信息。当选择一条边时，通过并查集判断该边的两个端点是否属于同一个连通分量，以避免形成环。

2. **并查集（Disjoint Set）**：

   - 并查集是一种数据结构，用于管理元素的不相交集合。它通常支持两种操作：查找（Find）和合并（Union）。查找操作用于确定某个元素属于哪个集合，合并操作用于将两个集合合并为一个集合。
   - 在Kruskal算法中，我们可以使用并查集来快速判断两个顶点是否属于同一个连通分量。当我们遍历边并选择加入最小生成树时，可以通过并查集来检查该边的两个端点是否已经在同一个连通分量中，以避免形成环。

   ```python
   class UnionFind:
       def __init__(self, n):
           self.parent = list(range(n))
           self.rank = [0] * n
   
       def find(self, x):
           if self.parent[x] != x:
               self.parent[x] = self.find(self.parent[x])
           return self.parent[x]
   
       def union(self, x, y):
           px, py = self.find(x), self.find(y)
           if self.rank[px] > self.rank[py]:
               self.parent[py] = px
           else:
               self.parent[px] = py
               if self.rank[px] == self.rank[py]:
                   self.rank[py] += 1
   
   def kruskal(n, edges):
       uf = UnionFind(n)
       edges.sort(key=lambda x: x[2])
       res = 0
       for u, v, w in edges:
           if uf.find(u) != uf.find(v):
               uf.union(u, v)
               res += w
       if len(set(uf.find(i) for i in range(n))) > 1:
           return -1
       return res
   
   n, m = map(int, input().split())
   edges = []
   for _ in range(m):
       u, v, w = map(int, input().split())
       edges.append((u, v, w))
   print(kruskal(n, edges))
   ```

   





















## Useful things

常见debug点：

词典是不是因为重复值被覆盖

是不是有重复值

是不是有孤立点

输入是一组还是多组

有没有考虑0，不止一位数，负数，空

注意节点序号是从0开始还是从1开始

用到优先队列的时候，一定要把weight放在第一位

行列有没有弄反

索引是不是从0开始！！！！尤其在树，图的问题中，一定注意



```
numlist=[*map(int,input().split())]
heapq.heapify(numlist)
# 注意这里不要写成numlist=heapq.heapify(numlist)，会返回none
```

格式化输出：

```python
print(f'Cube = {answer[i][0]}, Triple = ({later})')
```

保留两位小数：

```python
num = 123.456789
formatted_num = "{:.2f}".format(num)
print(formatted_num)  # 输出: 123.46
print("{:.6f}".format(result))
```

```python
python复制代码num = 123.456789
formatted_num = f"{num:.2f}"
print(formatted_num)  # 输出: 123.46
```

自定标准的max：

```python
# 找到最长的字符串的长度
max_len = len(max(lt, key = lambda x: len(x)))
```

math的向上取整：

```python
from math import ceil
# 按照自定义规则排序列表
lt.sort(key = lambda x: x * ceil(2 * max_len / len(x)))
# 如果列表中是字符串类型的数字，此时sort是：首先比较第一个字符，如果相同则比较下一个字符
# 比如排序后的是：['1', '10', '12', '2', '20', '3']
# 向下取整：
math.floor(33.5)  # 33
```

处理不定项输入：

```python
while True:
    try:
        balabala
    except EOFError:
        break
```

检查某个列表中是否有某个数，可以先用set处理列表来提速

队列使用：

```
from collections import deque

```

各种判断字符类型：

```
if char.isalpha():  # 如果是字母
```

### index

```
python复制代码s = "Hello, world!"
print(s.index("world"))  # 输出: 7
print(s.index("o", 5))   # 输出: 8
print(s.index("x"))      # 抛出ValueError: substring not found
```

### find

```
python复制代码s = "Hello, world!"
print(s.find("world"))  # 输出: 7
print(s.find("o", 5))   # 输出: 8
print(s.find("x"))      # 输出: -1
```

### 主要区别

1. **异常处理**：
   - `index`：如果子字符串未找到，抛出 `ValueError` 异常。
   - `find`：如果子字符串未找到，返回 `-1`。

import heapq的用法：默认最小堆，要实现最大堆使用负数

Python中heapq模块中一些常用函数的介绍：

1. heapq.heapify(iterable)：将可迭代对象转换为堆。该函数的时间复杂度为O(n)，其中n是可迭代对象的长度。
2. heapq.heappush(heap, item)：将元素item插入到堆中，并保持堆的不变性。
3. heapq.heappop(heap)：从堆中弹出并返回最小值（对于最小堆），或最大值（对于最大堆）。
4. heapq.heappushpop(heap, item)：将元素item插入到堆中，并返回弹出的最小值（对于最小堆），或最大值（对于最大堆）。
5. heapq.heapreplace(heap, item)：弹出并返回堆中的最小值（对于最小堆），或最大值（对于最大堆），然后将元素item插入到堆中。
6. heapq.nlargest(n, iterable)：返回可迭代对象中最大的n个元素。
7. heapq.nsmallest(n, iterable)：返回可迭代对象中最小的n个元素。

下面是一个示例，演示了如何使用heapq模块中的函数来操作堆：

```
python复制代码import heapq

# 创建一个空堆
heap = []

# 向堆中插入元素
heapq.heappush(heap, 5)
heapq.heappush(heap, 3)
heapq.heappush(heap, 7)
heapq.heappush(heap, 1)

# 从堆中弹出并返回最小值
print(heapq.heappop(heap))  # 输出：1

# 向堆中插入元素，并返回弹出的最小值
print(heapq.heappushpop(heap, 2))  # 输出：2

# 弹出并返回堆中的最小值，然后将元素插入到堆中
print(heapq.heapreplace(heap, 6))  # 输出：2

# 返回堆中最大的两个元素
print(heapq.nlargest(2, heap))  # 输出：[7, 6]

# 返回堆中最小的两个元素
print(heapq.nsmallest(2, heap))  # 输出：[3, 5]
```

去除重复值：

```
numbers = list(dict.fromkeys(numbers))
numbers=list(set(numbers))
```

两个字符是不是从。。。开始：

```
if phone_num[i+1].startswith(phone_num[i]):
```

```
print(chr(65))
print(ord('A'))
print(ord('a'))
print(ord('b'))
A
65
97
98

```



## 作业复习



## 模考题目复习







给一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，

请你统计并输出其中完全由 1 组成的 正方形 子矩阵的个数。
